# Семейский Ярослав  Уибо-14-24
## Анализ алгоритмов сортировки и поиска  

В этом документе представлен детальный анализ одиннадцати классических алгоритмов сортировки и поиска.  
Каждый раздел содержит определение, краткое описание логики работы и анализ временной сложности.

---

### 1. Сортировка выбором (Selection Sort)

**Определение:**  
Сортировка выбором — это алгоритм, который делит массив на отсортированную и неотсортированную части. На каждом шаге он находит минимальный элемент в неотсортированной части и перемещает его в начало.

**Анализ:**  
- Внешний цикл выполняется `n - 1` раз.  
- Внутренний цикл ищет минимум в оставшейся части массива.  
- Общее количество сравнений ≈ `n*(n-1)/2`.  

**Временная сложность:** `O(n²)`  
**Почему:** Два вложенных цикла, где внутренний полностью зависит от `n`.

---

### 2. Сортировка обменом (Bubble Sort)

**Определение:**  
Пузырьковая сортировка многократно проходит по массиву, сравнивая соседние элементы и меняя их местами, если они расположены в неверном порядке.

**Анализ:**  
- Внешний цикл выполняется `n - 1` раз.  
- В худшем случае внутренний цикл делает почти `n²/2` сравнений.  
- Возможна оптимизация — если за проход не было обменов, алгоритм завершает работу.  

**Временная сложность:**  
- Худший случай — `O(n²)`  
- Лучший — `O(n)` (уже отсортирован массив).  
- Средний — `O(n²)`  

---

### 3. Сортировка вставками (Insertion Sort)

**Определение:**  
Сортировка вставками строит отсортированную часть массива, вставляя каждый новый элемент в нужное место относительно уже отсортированных.

**Анализ:**  
- Каждый новый элемент сравнивается с предыдущими и вставляется на своё место.  
- В худшем случае количество сдвигов и сравнений равно `n*(n-1)/2`.  

**Временная сложность:**  
- Худший случай — `O(n²)`  
- Лучший случай — `O(n)`  
- Средний случай — `O(n²)`  

---

### 4. Сортировка слиянием (Merge Sort)

**Определение:**  
Сортировка слиянием — это рекурсивный алгоритм, использующий принцип *«разделяй и властвуй»*. Массив делится пополам, каждая половина сортируется отдельно, после чего они объединяются в один отсортированный массив.

**Анализ:**  
- Глубина рекурсии — `log n`.  
- На каждом уровне объединяются все элементы, то есть `O(n)` операций.  
- Итого: `n * log n`.  

**Временная сложность:** `O(n log n)`  

---

### 5. Сортировка Шелла (Shell Sort)

**Определение:**  
Сортировка Шелла — улучшенный вариант сортировки вставками, где элементы сравниваются на расстоянии (gap), постепенно уменьшающемся до 1.

**Анализ:**  
- Производительность зависит от последовательности шагов (gap).  
- При шаге `n/2, n/4, ...` сложность обычно между `O(n^(3/2))` и `O(n log² n)`.  
- Для последовательности Кнута — около `O(n^(3/2))`.  

**Временная сложность:**  
- Средний случай — `O(n^(3/2))`  
- Худший — `O(n²)`  

---

### 6. Быстрая сортировка (Quick Sort)

**Определение:**  
Быстрая сортировка — эффективный алгоритм, основанный на выборе *опорного элемента* (pivot) и разбиении массива на части: меньше и больше опорного.

**Анализ:**  
- При удачном выборе опорного элемента массив делится пополам.  
- При неудачном — дерево рекурсии вырождается в цепочку.  

**Временная сложность:**  
- Средний случай — `O(n log n)`  
- Худший — `O(n²)`  
- Лучший — `O(n log n)`  

---

### 7. Пирамидальная сортировка (Heap Sort)

**Определение:**  
Пирамидальная сортировка использует структуру данных *двоичная куча*. Алгоритм сначала строит кучу, затем поочерёдно извлекает из неё максимальный элемент.

**Анализ:**  
- Построение кучи — `O(n)`.  
- Каждый вызов heapify после удаления элемента — `O(log n)`.  
- Всего таких вызовов `n`.  

**Временная сложность:** `O(n log n)`  

---

### 8. Последовательный поиск (Linear Search)

**Определение:**  
Последовательный поиск — простейший метод поиска элемента, при котором проверяются все элементы по порядку до нахождения совпадения.

**Анализ:**  
- В худшем случае нужно проверить все `n` элементов.  
- В лучшем — элемент находится сразу.  

**Временная сложность:**  
- Худший — `O(n)`  
- Лучший — `O(1)`  

---

### 9. Бинарный поиск (Binary Search)

**Определение:**  
Бинарный поиск применяется для отсортированных массивов и работает по принципу деления области поиска пополам.

**Анализ:**  
- На каждом шаге диапазон сокращается вдвое.  
- Количество шагов ≈ `log₂ n`.  

**Временная сложность:** `O(log n)`  

---

### 10. Интерполирующий поиск (Interpolation Search)

**Определение:**  
Интерполяционный поиск улучшает бинарный, используя формулу для прогнозирования позиции элемента на основе его значения и распределения данных.

**Анализ:**  
- Быстрее бинарного при равномерных данных.  
- Может деградировать до линейного при неравномерном распределении.  

**Временная сложность:**  
- Средний случай — `O(log log n)`  
- Худший — `O(n)`  

---

### 11. Поиск по Фибоначчи (Fibonacci Search)

**Определение:**  
Алгоритм поиска по Фибоначчи использует числа Фибоначчи для деления массива на части, аналогично бинарному поиску, но с другими пропорциями.

**Анализ:**  
- Сокращает диапазон поиска на каждом шаге, используя меньшие числа Фибоначчи.  
- Количество итераций пропорционально `log n`.  

**Временная сложность:** `O(log n)`  
